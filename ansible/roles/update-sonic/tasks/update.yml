# SONiC to SONiC image update on the running device.
# Command example:
# ansible-playbook -i inventory --limit SWITCH update.yml --tags update -b -vvvvv -e CMD image_url=URL

- name: Simx workaround
  set_fact: simx=no
  when: simx is not defined

- fail: msg="image_url variable should be provided."
  when: image_url is not defined

- set_fact: timestamp="{{lookup('pipe','date +%Y%m%d%H%M%S')}}"

- set_fact: filename="/tmp/update_image_{{ timestamp }}"
- debug: var=filename

- name: Download SONiC image.
  local_action: get_url url={{ image_url }} dest={{ filename }}

- name: Upload SONiC image to device.
  copy:
    src: "{{ filename }}"
    dest: "{{ filename }}"

- name: Remove SONiC image from local server.
  local_action: file path={{ filename }} state=absent

- name: List current images
  command: sonic_installer list
  register: current_images_output
  ignore_errors: yes

- name: Update SONiC image.
  command: sonic_installer install {{ filename }} -y
  register: update_output
  ignore_errors: yes

- fail: msg="{{ update_output.stdout }}"
  when:
    - update_output.rc != 0
    - "'running SONiC has the same version' not in update_output.stdout"

- block:
    - name: Reboot device.
      command: reboot
      async: 300
      poll: 0
      ignore_errors: true

    - name: Wait for device to go down.
      wait_for:
        host: "{{ ansible_ssh_host }}"
        port: 22
        state: stopped
        delay: 10
        timeout: 300
      connection: local

    - name: Wait for device to come back.
      wait_for:
        host: "{{ ansible_ssh_host }}"
        port: 22
        state: started
        delay: 10
        timeout: 900
      connection: local

  when: "'running SONiC has the same version' not in update_output.stdout"

- name: "Wait until SONiC init is done"
  command: bash -c 'docker ps | grep [s]yncd'
  register: result
  until: result.rc == 0
  retries: 60
  delay: 5
  ignore_errors: yes

- fail: msg="SONiC init is failed. Aborting..."
  when: result.rc != 0

# When running firmware version does not match current image, the output of mlxfwmanager --query
# will have a line containing "FW (Running)".
- name: Check current running firmware version
  command: bash -c 'mlxfwmanager --query'
  register: firmware_query_output
  until: firmware_query_output.rc == 0
  retries: 12
  delay: 10
  ignore_errors: true
  when: simx != 'yes'

- fail: msg="Unable to get firmware information. Aborting..."
  when: simx != 'yes' and firmware_query_output.rc != 0

- name: Firmware version info
  debug: msg="{{ firmware_query_output.stdout_lines }}"
  when: simx != 'yes'

- block:

  - name: If unmached running FW ver, reboot to recover
    command: reboot
    async: 300
    poll: 0
    ignore_errors: true

  - name: Wait for device to go down.
    wait_for:
      host: "{{ ansible_ssh_host }}"
      port: 22
      state: stopped
      delay: 10
      timeout: 300
    connection: local

  - name: Wait for device to come back.
    wait_for:
      host: "{{ ansible_ssh_host }}"
      port: 22
      state: started
      delay: 10
      timeout: 900
    connection: local

  - name: Wait until possible FW updating is done
    command: bash -c 'ps aux | grep "[m]lxfwmanager" ; [ $? == 1 ]'
    register: output
    until: output.rc == 0
    retries: 12
    delay: 10
    ignore_errors: true

  - name: Check current running firmware version again
    command: bash -c 'mlxfwmanager --query'
    register: firmware_query_output_2
    until: firmware_query_output_2.rc == 0
    retries: 12
    delay: 10
    ignore_errors: true

  - name: Firmware version info
    debug: msg="{{ firmware_query_output_2.stdout_lines }}"

  - name: If still unmatched running FW version, assert failure
    fail: msg="Running firmware version does not match current image. Not recovered after reboot. Aborting..."
    when: firmware_query_output_2.stdout.find("FW (Running)") != -1

  when: simx != 'yes' and firmware_query_output.stdout.find("FW (Running)") != -1

- block:

    # "config load_minigraph -y" needs to stop swss. If swss is not fully started, stopping swss may fail.
    # This is the workaround to wait until swss service is started
    - name: Wait for swss service to start
      command: systemctl -p ActiveState -p SubState show swss
      register: service_swss_state
      until: (service_swss_state.stdout.find("ActiveState=active") >= 0) and (service_swss_state.stdout.find("SubState=running") >= 0)
      retries: 10
      delay: 30

    - name: Deploy minigraph file.
      copy:
        src: "minigraph/{{ dut_minigraph }}"
        dest: "/etc/sonic/minigraph.xml"

    - name: Deploy specific device configuration files
      include: deploy_device_configs.yml
      vars:
        dut_hwsku: "{{ sonic_hwsku }}"
        dut_hostname: "{{ ansible_ssh_host }}"

    - name: Reload minigraph.
      shell: config load_minigraph -y

    - name: Save config.
      shell: config save -y

  when: dut_minigraph is defined

- name: Gathering minigraph facts about the device
  minigraph_facts: host={{ inventory_hostname }}
  become: no
  tags: always

- block:

    - set_fact:
        intfs: "{% if minigraph_ports|length > 1 %}{{ '{' }}{% endif %}{{ minigraph_ports.keys() | join(',') }}{% if minigraph_ports|length > 1 %}{{ '}' }}{% endif %}"

    - name: Verify interfaces are up correctly
      command: bash -c "cat /sys/class/net/{{ intfs }}/operstate"
      register: out
      until: (out.rc == 0) and (out.stdout.find("down") == -1)
      retries: 30
      delay: 10

- block:

    - set_fact:
        pc_intfs: "{% if minigraph_portchannels|length > 1 %}{{ '{' }}{% endif %}{{ minigraph_portchannels.keys() | join(',') }}{% if minigraph_portchannels|length > 1 %}{{ '}' }}{% endif %}"

    - name: Verify PortChannel interfaces are up correctly
      command: bash -c "cat /sys/class/net/{{ pc_intfs }}/operstate"
      register: out
      until: (out.rc == 0) and (out.stdout.find("down") == -1)
      retries: 30
      delay: 10

  when: (topo == "t0") or (topo == "t1-lag")

- block:

    - set_fact:
        vlan_intfs: "{% if minigraph_vlans|length > 1 %}{{ '{' }}{% endif %}{{ minigraph_vlans.keys() | join(',') }}{% if minigraph_vlans|length > 1 %}{{ '}' }}{% endif %}"

    - name: Verify VLAN interfaces are up correctly
      command: bash -c "cat /sys/class/net/{{ vlan_intfs }}/operstate"
      register: out
      until: (out.rc == 0) and (out.stdout.find("down") == -1)
      retries: 30
      delay: 10

  when: topo == "t0"
